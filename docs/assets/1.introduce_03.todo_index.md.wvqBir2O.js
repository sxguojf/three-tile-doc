import{_ as e,c as t,o as r,a2 as o}from"./chunks/framework.CJqd0DOR.js";const c=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"1.introduce/03.todo/index.md","filePath":"1.introduce/03.todo/index.md","lastUpdated":1761368239000}'),i={name:"1.introduce/03.todo/index.md"};function l(d,a,n,h,s,p){return r(),t("div",null,a[0]||(a[0]=[o('<p>当前版本为 V0.10.3</p><hr><p><s>目前版本为 V0.8.x，下一版本升级思路：V0.9.0 已发布</s> ：</p><p>一个开发框架想持续发展下去，必须要有一个清晰的架构，否则随着功能的增加，代码会越来越混乱。three-tile 经过数十次重构（其中有 3 次基本上是推到重来），目前架构已经比较清晰，各模型职责也比较明确。</p><h2 id="_1-缩减核心库功能-已完成" tabindex="-1">1. 缩减核心库功能（已完成） <a class="header-anchor" href="#_1-缩减核心库功能-已完成" aria-label="Permalink to &quot;1. 缩减核心库功能（已完成）&quot;">​</a></h2><p>经验告诉我，个人开发的较底层的框架，核心功能不能太多，要采用灵活的扩展机制，吸引其他开发者参与才能持续。个人精力有限，无法做到面面俱到包罗万象，太多的外围功能拖累核心功能的开发。像 leaflet，只维护一个很小的框架，通过扩展方式逐步实现更多功能，效果非常好；而 Mapbox、Cesium 等有大厂支持，功能全面，但动辄数十万行代码，个人很难做到。</p><p>从 V0.10.3 开始，代码结构做了调整，three-tile 核心只保留基础功能，将原来的 three-tile.plugin 命名空间独立成一个子包，与核心功能完全独立，未来功能扩展将通过插件机制实现。</p><h2 id="_2-完善插件架构-放弃" tabindex="-1">2. 完善插件架构（放弃） <a class="header-anchor" href="#_2-完善插件架构-放弃" aria-label="Permalink to &quot;2. 完善插件架构（放弃）&quot;">​</a></h2><p><s>目前插件架构还不够完善，虽说叫插件，但实际上就是普通模块，并没有引入插件管理机制，插件何时加载、卸载、执行等都不明确</s>。已完成，但感觉用会增加使用者学习成本，不如直接 import 直观，暂放弃。</p><h2 id="_3-修改加载器接口-已完成" tabindex="-1">3. 修改加载器接口（已完成） <a class="header-anchor" href="#_3-修改加载器接口-已完成" aria-label="Permalink to &quot;3. 修改加载器接口（已完成）&quot;">​</a></h2><p>目前的加载器接口设计不太合理，加载器接口 ITileLoader 对瓦片 Tile 类有依赖，而 Tile 类又依赖了加载器接口，产生交叉依赖，对我这样一个对痴迷于设计模式的人来说，一直耿耿于怀（交叉依赖在 js/ts/python 等语言里很常见，连个警告都没有）。计划去掉 ITileLoader 对 Tile 的依赖，ITileLoader 的 load 函数不返回 Tile，而是返回纹理和几何体。</p><h2 id="_4-提升地图渲染质量-未完成" tabindex="-1">4. 提升地图渲染质量（未完成） <a class="header-anchor" href="#_4-提升地图渲染质量-未完成" aria-label="Permalink to &quot;4. 提升地图渲染质量（未完成）&quot;">​</a></h2><p>目前地图渲染质量感觉与 MapBox、Cesium 相当，但与 google earth 还是有差距，虽然不了解 google earth 的渲染算法，感觉主要是大气效果和地形法向量算法需要优化，three-tile 的大气效果仅使用了简单的对数雾，在地图视角变化时根据经验公式对雾的强度进行调整，有些太简陋，网上有一些大气渲染算法，采用体积雾方式，怕影响渲染速度，还没尝试。地形法向量目前用的是顶点法向量，但既然已经有网格地形数据，就可以计算像素级法向量，搞个法向量贴图上去效果会不会好一些。总之，地图渲染效果只能一点一点实验，到底有没有效果、资源占用和效率是否能接受还无法估计。</p><h2 id="_5-矢量瓦片的支持-已完成" tabindex="-1">5. 矢量瓦片的支持（已完成） <a class="header-anchor" href="#_5-矢量瓦片的支持-已完成" aria-label="Permalink to &quot;5. 矢量瓦片的支持（已完成）&quot;">​</a></h2><p>很多同学希望支持矢量瓦片的加载，但我对矢量瓦片了解不多，一直没有动手写。目前基本思路是把矢量瓦片绘制到 canvas 上作为瓦片纹理，也就是需要一个函数，传入矢量瓦片 arraybuffer，返回画好的 canvas， 希望能有同学帮助实现。</p><h2 id="_6-提升运行效率-已完成" tabindex="-1">6. 提升运行效率（已完成） <a class="header-anchor" href="#_6-提升运行效率-已完成" aria-label="Permalink to &quot;6. 提升运行效率（已完成）&quot;">​</a></h2><p>引入线程池。线程频繁创建和释放对性能有一定影响，引入线程池对线程进行复用。瓦片 LOD 有些繁琐，还有优化空间。</p><h2 id="_7-地图坐标单位改为米-已完成" tabindex="-1">7. 地图坐标单位改为米（已完成） <a class="header-anchor" href="#_7-地图坐标单位改为米-已完成" aria-label="Permalink to &quot;7. 地图坐标单位改为米（已完成）&quot;">​</a></h2><p>地图坐标单位由公里改为为米，与主流 GIS 类软件保持一致，这是一个比较大的改动，需要注意。</p>',19)]))}const u=e(i,[["render",l]]);export{c as __pageData,u as default};
