import{_ as i,C as o,c as h,o as a,a2 as r,b as s,w as t,a as d,G as n,a3 as m}from"./chunks/framework.CJqd0DOR.js";const B=JSON.parse('{"title":"概览","description":"","frontmatter":{},"headers":[],"relativePath":"2.base/01.index.md","filePath":"2.base/01.index.md","lastUpdated":1761368239000}'),u={name:"2.base/01.index.md"};function p(E,e,c,b,A,_){const l=o("Mermaid");return a(),h("div",null,[e[1]||(e[1]=r('<h1 id="概览" tabindex="-1">概览 <a class="header-anchor" href="#概览" aria-label="Permalink to &quot;概览&quot;">​</a></h1><p>three-tile 是基于 threejs 开发三维瓦片地图框架，它提供一个地图三维模型（Mesh）。</p><h2 id="_1-threejs" tabindex="-1">1. threejs <a class="header-anchor" href="#_1-threejs" aria-label="Permalink to &quot;1. threejs&quot;">​</a></h2><ul><li>threejs 是一个基于 WebGL 的 JavaScript 3D 库，它对 WebGL 进行了封装，使 Web 下开发 3D 应用更加容易。three.js 的官方网站是<a href="http://threejs.org/" target="_blank" rel="noreferrer">http://threejs.org/</a>。</li><li>three-tile 的开发，需要先了解 threejs 的基础知识。如果你对 threejs 还不熟悉，可以先从它的官方文档和示例开始学习：<a href="https://threejs.org/manual/#zh/fundamentals" target="_blank" rel="noreferrer">https://threejs.org/manual/#zh/fundamentals</a></li><li>three-tile 只提供了模型，很多功能需要使用 threejs 来完成，虽然麻烦了点，但可以充分利用 threejs 的强大生态，threejs 的各种特效、模型都完美衔接。</li></ul><h2 id="_2-webgis" tabindex="-1">2. WebGIS <a class="header-anchor" href="#_2-webgis" aria-label="Permalink to &quot;2. WebGIS&quot;">​</a></h2><ul><li>既然是地图框架开发，那基本的 GIS 知识是必须的。包括地图坐标系、地图投影、地图数据服务、瓦片模型等。</li></ul><p>todo: 补充 GIS 基础知识。</p><h2 id="_3-three-tile" tabindex="-1">3. three-tile <a class="header-anchor" href="#_3-three-tile" aria-label="Permalink to &quot;3. three-tile&quot;">​</a></h2><p>three-tile 是基于 threejs 开发的地图三维框架，目标是提供一个轻量级的、易于使用的三维地图模型。</p><p>three-tile 采用面向对象设计，使用大量设计模式思想，如抽象工厂、模板方法、代理模式、组合模式等。目前各模块间耦合较少，尽量做到单向依赖，职责分明，架构还算清晰：</p>',10)),(a(),s(m,null,{default:t(()=>[n(l,{id:"mermaid-48",class:"mermaid",graph:"graph%20TD%0A%20%20%20%20A%5B%E5%9C%B0%E5%9B%BE%E6%A8%A1%E5%9E%8B%20map%5D%20--%3E%20B%5B%E7%93%A6%E7%89%87%E6%A0%91%20tile%5D%0A%20%20%20%20B%20--%3E%20C%5B%E7%93%A6%E7%89%87%E5%8A%A0%E8%BD%BD%E5%99%A8%20loader%5D%0A%20%20%20%20C%20--%3E%20I%5B%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%B7%A5%E5%8E%82%20LoaderFactory%5D%0A%20%20%20%20I%20--%3E%20D%5B%E5%BD%B1%E5%83%8F%E5%8A%A0%E8%BD%BD%E5%99%A8%20MarterialLoader%5D%0A%20%20%20%20D%20--%3E%20E%5B%E7%93%A6%E7%89%87%E6%9D%90%E8%B4%A8%20material%5D%0A%20%20%20%20I%20--%3E%20F%5B%E5%9C%B0%E5%BD%A2%E5%8A%A0%E8%BD%BD%E5%99%A8%20TileGeometerLoader%5D%0A%20%20%20%20F%20--%3E%20G%5B%E7%93%A6%E7%89%87%E5%87%A0%E4%BD%95%E4%BD%93%20gometery%5D%0A%20%20%20%20C%20--%3E%20H%5B%E7%93%A6%E7%89%87%E6%95%B0%E6%8D%AE%E6%BA%90%20source%5D%0A"})]),fallback:t(()=>e[0]||(e[0]=[d(" Loading... ")])),_:1})),e[2]||(e[2]=r('<h3 id="一个典型的地图加载流程如下" tabindex="-1">一个典型的地图加载流程如下： <a class="header-anchor" href="#一个典型的地图加载流程如下" aria-label="Permalink to &quot;一个典型的地图加载流程如下：&quot;">​</a></h3><ol><li>地图模型创建根瓦片</li><li>根瓦片根据其与摄像机距离进行细分或合并生成四叉树</li><li>四叉树上各个瓦片根据其 xyz 坐标编号向瓦片加载器请求瓦片模型</li><li>瓦片加载器根据其数据源，调用加载器工厂取得影像加载器和地形加载器</li><li>影像加载器和地形加载器从数据源中读取数据，生成瓦片材质和几何体</li><li>瓦片加载器将材质和几何体合并生成瓦片 Mesh，并返回作为子模型添加进瓦片</li><li>渲染瓦片树上所有叶子瓦片</li></ol><ul><li><h3 id="地图模型-map" tabindex="-1">地图模型 map <a class="header-anchor" href="#地图模型-map" aria-label="Permalink to &quot;地图模型 map&quot;">​</a></h3><p>地图模型 TileMap 继承于 threejs 的 Object3D，封装了瓦片树、加载器、数据源等对象，增加了地图投影、坐标转换等地图相关的属性方法。它会定时更新瓦片树（目前设置为 1 秒更新 5 次）实现地图的渲染。对地图的绝大部分操作均可通它过完成，普通开发者并不需要深入关注加载器、材质、几何体等模块。</p></li><li><h3 id="瓦片树-tile" tabindex="-1">瓦片树 tile <a class="header-anchor" href="#瓦片树-tile" aria-label="Permalink to &quot;瓦片树 tile&quot;">​</a></h3><p>瓦片树是 three-tile 的核心，它也继承于 Object3D，实现了一个动态 LOD 模型，作为子模型加入 TileMap。它通过一个四叉树对各层级瓦片进行管理调度，计算其瓦片与摄像机的距离，以决定是否需要细分或合并瓦片，我把这种模型命名为 DLOD(Dynamic Level Of Details)。地图模型 TileMap 会定时调用 Tile.update()更新瓦片树，并根据瓦片的 xyz 坐标调用瓦片加载器请求瓦片模型。</p></li><li><h3 id="瓦片数据源-source" tabindex="-1">瓦片数据源 Source <a class="header-anchor" href="#瓦片数据源-source" aria-label="Permalink to &quot;瓦片数据源 Source&quot;">​</a></h3><p>瓦片数据源用来定义瓦片的数据来源，包括瓦片数据类型（格式）、url 模板、瓦片层级等信息，以及根据瓦片 xyz 坐标生成具体瓦片 url 的方法。对于标准的 WMTS、TMS 等 标准的 xyz 瓦片服务，仅需提供瓦片数据服务的 url 模板即可，其他特殊编码的数据源(如 bing 瓦片)，可以继承 TileSource 类重写 getUrl 方法实现。three-tile 内置了主流地图厂商瓦片数据源定义，但强烈建议用户自己定义，主要是因为厂商数据源 url 规则会变化或失效，内置数据源不能及时跟上，另外自己定义也非常简单，与 leaflet、cesium 等方法一致。</p></li><li><h3 id="瓦片加载器-loader" tabindex="-1">瓦片加载器 loader <a class="header-anchor" href="#瓦片加载器-loader" aria-label="Permalink to &quot;瓦片加载器 loader&quot;">​</a></h3><p>瓦片加载器负责瓦片的下载、解析，瓦片树在更新过程中调用它来下载地图数据并生成瓦片模型。它会根据传入的瓦片数据源和瓦片 xyz 坐标，调用影像加载器和地形加载器生成瓦片材质和几何体。由于要兼容各厂家的地图数据，内部有一个加载器工厂（抽象工厂），它能根据地图数据类型取得相应的影像和地形加载器，并调用它们生成瓦片材质和几何体。</p></li><li><h3 id="影像加载器-tilemarterialloader" tabindex="-1">影像加载器 TileMarterialLoader <a class="header-anchor" href="#影像加载器-tilemarterialloader" aria-label="Permalink to &quot;影像加载器 TileMarterialLoader&quot;">​</a></h3><p>影像加载器负责影像数据的下载、解析，并生成对应的材质，不同格式影像数据对应不同影像加载器。瓦片加载器调用它实现影像数据的下载和解析。</p></li><li><h3 id="地形加载器-tilegeometerloader" tabindex="-1">地形加载器 TileGeometerLoader <a class="header-anchor" href="#地形加载器-tilegeometerloader" aria-label="Permalink to &quot;地形加载器 TileGeometerLoader&quot;">​</a></h3><p>地形加载器负责地形数据的下载、解析，并生成对应的几何体，不同格式地形数据对应不同地形加载器。瓦片加载器调用它实现地形数据的下载和解析。</p></li><li><h3 id="瓦片材质-material" tabindex="-1">瓦片材质 material <a class="header-anchor" href="#瓦片材质-material" aria-label="Permalink to &quot;瓦片材质 material&quot;">​</a></h3><p>瓦片材质即瓦片模型的 Material，它比较简单，继承于 threejs 的 MeshStandardMaterial，内建的影像加载器下载数据会创建它。如果你对该材质的渲染效果不满意，可以自己写一个材质替换它，比如用着色器写一些特效。</p></li><li><h3 id="瓦片几何体-geometty" tabindex="-1">瓦片几何体 geometty <a class="header-anchor" href="#瓦片几何体-geometty" aria-label="Permalink to &quot;瓦片几何体 geometty&quot;">​</a></h3><p>瓦片几何体即瓦片模型的 Geometry，它继承于 threejs 的 BufferGeometry，增加了根据 DEM 数组、根据顶点数据创建瓦片 Geometry 的方法。下载数据后，将数据解析成 DEM 或者顶点数据传入它即可生成瓦片 Geometry。</p></li><li><h3 id="插件-plugin" tabindex="-1">插件 plugin <a class="header-anchor" href="#插件-plugin" aria-label="Permalink to &quot;插件 plugin&quot;">​</a></h3><p>插件模块主要包括一些非核心的扩展功能，各种格式影像和地形数据加载器也包含在此模块中，运行时注入加载器工厂，实现对对不同厂商不同格式数据的支持。</p></li></ul>',3))])}const f=i(u,[["render",p]]);export{B as __pageData,f as default};
