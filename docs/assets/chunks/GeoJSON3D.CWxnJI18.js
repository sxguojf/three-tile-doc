var ae=Object.defineProperty;var ce=(a,e,s)=>e in a?ae(a,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):a[e]=s;var V=(a,e,s)=>ce(a,typeof e!="symbol"?e+"":e,s);import{C as le,d as ie,e as C,Q as ue,B as _,at as fe,au as j,av as he,aw as de,K as q,ax as pe,t as ge,v as P,Z as xe,ay as X,S as ye,m as me,k as Te,N as we,l as Me,j as Ae,i as Ee,o as Ie,R as Re,n as be,_ as Le,F as Ne,az as Se,V as _e,aA as Ce,aB as Ue,al as ve,as as Fe,aC as Oe,s as Be,y as Ge,ai as De,ak as ze,aD as Pe}from"./index.CqI7X3xo.js";import{g as ke}from"./lil-gui.module.min.Vka56b52.js";import{a as He,b as Ve,u as je}from"./style.Ddmk4huO.js";import{u as Ye}from"./useState.EiXjSKHF.js";import{u as Ke}from"./useSky.hmx3ZDdW.js";import{m as qe}from"./BufferGeometryUtils.CkhbY6lp.js";import{d as We,p as B,v as Xe,x as Je,c as J,o as Z,j as N,e as Ze,t as G,k as z,_ as Qe}from"./framework.xbTv8SNN.js";const Q={POSITION:["byte","byte normalized","unsigned byte","unsigned byte normalized","short","short normalized","unsigned short","unsigned short normalized"],NORMAL:["byte normalized","short normalized"],TANGENT:["byte normalized","short normalized"],TEXCOORD:["byte","byte normalized","unsigned byte","short","short normalized","unsigned short"]};class k{constructor(){this.textureUtils=null,this.pluginCallbacks=[],this.register(function(e){return new cs(e)}),this.register(function(e){return new ls(e)}),this.register(function(e){return new ds(e)}),this.register(function(e){return new ps(e)}),this.register(function(e){return new gs(e)}),this.register(function(e){return new xs(e)}),this.register(function(e){return new us(e)}),this.register(function(e){return new fs(e)}),this.register(function(e){return new hs(e)}),this.register(function(e){return new ys(e)}),this.register(function(e){return new ms(e)}),this.register(function(e){return new Ts(e)}),this.register(function(e){return new ws(e)}),this.register(function(e){return new Ms(e)})}register(e){return this.pluginCallbacks.indexOf(e)===-1&&this.pluginCallbacks.push(e),this}unregister(e){return this.pluginCallbacks.indexOf(e)!==-1&&this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e),1),this}setTextureUtils(e){return this.textureUtils=e,this}parse(e,s,i,t){const r=new as,n=[];for(let o=0,c=this.pluginCallbacks.length;o<c;o++)n.push(this.pluginCallbacks[o](r));r.setPlugins(n),r.setTextureUtils(this.textureUtils),r.writeAsync(e,s,t).catch(i)}parseAsync(e,s){const i=this;return new Promise(function(t,r){i.parse(e,t,r,s)})}}const T={POINTS:0,LINES:1,LINE_LOOP:2,LINE_STRIP:3,TRIANGLES:4,BYTE:5120,UNSIGNED_BYTE:5121,SHORT:5122,UNSIGNED_SHORT:5123,INT:5124,UNSIGNED_INT:5125,FLOAT:5126,ARRAY_BUFFER:34962,ELEMENT_ARRAY_BUFFER:34963,NEAREST:9728,LINEAR:9729,NEAREST_MIPMAP_NEAREST:9984,LINEAR_MIPMAP_NEAREST:9985,NEAREST_MIPMAP_LINEAR:9986,LINEAR_MIPMAP_LINEAR:9987,CLAMP_TO_EDGE:33071,MIRRORED_REPEAT:33648,REPEAT:10497},Y="KHR_mesh_quantization",L={};L[me]=T.NEAREST;L[Te]=T.NEAREST_MIPMAP_NEAREST;L[we]=T.NEAREST_MIPMAP_LINEAR;L[Me]=T.LINEAR;L[Ae]=T.LINEAR_MIPMAP_NEAREST;L[Ee]=T.LINEAR_MIPMAP_LINEAR;L[Ie]=T.CLAMP_TO_EDGE;L[Re]=T.REPEAT;L[be]=T.MIRRORED_REPEAT;const $={scale:"scale",position:"translation",quaternion:"rotation",morphTargetInfluences:"weights"},$e=new le,ee=12,es=1179937895,ss=2,se=8,ts=1313821514,ns=5130562;function D(a,e){return a.length===e.length&&a.every(function(s,i){return s===e[i]})}function is(a){return new TextEncoder().encode(a).buffer}function rs(a){return D(a.elements,[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1])}function os(a,e,s){const i={min:new Array(a.itemSize).fill(Number.POSITIVE_INFINITY),max:new Array(a.itemSize).fill(Number.NEGATIVE_INFINITY)};for(let t=e;t<e+s;t++)for(let r=0;r<a.itemSize;r++){let n;a.itemSize>4?n=a.array[t*a.itemSize+r]:(r===0?n=a.getX(t):r===1?n=a.getY(t):r===2?n=a.getZ(t):r===3&&(n=a.getW(t)),a.normalized===!0&&(n=q.normalize(n,a.array))),i.min[r]=Math.min(i.min[r],n),i.max[r]=Math.max(i.max[r],n)}return i}function re(a){return Math.ceil(a/4)*4}function K(a,e=0){const s=re(a.byteLength);if(s!==a.byteLength){const i=new Uint8Array(s);if(i.set(new Uint8Array(a)),e!==0)for(let t=a.byteLength;t<s;t++)i[t]=e;return i.buffer}return a}function te(){return typeof document>"u"&&typeof OffscreenCanvas<"u"?new OffscreenCanvas(1,1):document.createElement("canvas")}function ne(a,e){if(a.toBlob!==void 0)return new Promise(i=>a.toBlob(i,e));let s;return e==="image/jpeg"?s=.92:e==="image/webp"&&(s=.8),a.convertToBlob({type:e,quality:s})}class as{constructor(){this.plugins=[],this.options={},this.pending=[],this.buffers=[],this.byteOffset=0,this.buffers=[],this.nodeMap=new Map,this.skins=[],this.extensionsUsed={},this.extensionsRequired={},this.uids=new Map,this.uid=0,this.json={asset:{version:"2.0",generator:"THREE.GLTFExporter r"+fe}},this.cache={meshes:new Map,attributes:new Map,attributesNormalized:new Map,materials:new Map,textures:new Map,images:new Map},this.textureUtils=null}setPlugins(e){this.plugins=e}setTextureUtils(e){this.textureUtils=e}async writeAsync(e,s,i={}){this.options=Object.assign({binary:!1,trs:!1,onlyVisible:!0,maxTextureSize:1/0,animations:[],includeCustomExtensions:!1},i),this.options.animations.length>0&&(this.options.trs=!0),await this.processInputAsync(e),await Promise.all(this.pending);const t=this,r=t.buffers,n=t.json;i=t.options;const o=t.extensionsUsed,c=t.extensionsRequired,l=new Blob(r,{type:"application/octet-stream"}),h=Object.keys(o),u=Object.keys(c);if(h.length>0&&(n.extensionsUsed=h),u.length>0&&(n.extensionsRequired=u),n.buffers&&n.buffers.length>0&&(n.buffers[0].byteLength=l.size),i.binary===!0){const w=new FileReader;w.readAsArrayBuffer(l),w.onloadend=function(){const f=K(w.result),p=new DataView(new ArrayBuffer(se));p.setUint32(0,f.byteLength,!0),p.setUint32(4,ns,!0);const g=K(is(JSON.stringify(n)),32),y=new DataView(new ArrayBuffer(se));y.setUint32(0,g.byteLength,!0),y.setUint32(4,ts,!0);const x=new ArrayBuffer(ee),M=new DataView(x);M.setUint32(0,es,!0),M.setUint32(4,ss,!0);const E=ee+y.byteLength+g.byteLength+p.byteLength+f.byteLength;M.setUint32(8,E,!0);const d=new Blob([x,y,g,p,f],{type:"application/octet-stream"}),m=new FileReader;m.readAsArrayBuffer(d),m.onloadend=function(){s(m.result)}}}else if(n.buffers&&n.buffers.length>0){const w=new FileReader;w.readAsDataURL(l),w.onloadend=function(){const f=w.result;n.buffers[0].uri=f,s(n)}}else s(n)}serializeUserData(e,s){if(Object.keys(e.userData).length===0)return;const i=this.options,t=this.extensionsUsed;try{const r=JSON.parse(JSON.stringify(e.userData));if(i.includeCustomExtensions&&r.gltfExtensions){s.extensions===void 0&&(s.extensions={});for(const n in r.gltfExtensions)s.extensions[n]=r.gltfExtensions[n],t[n]=!0;delete r.gltfExtensions}Object.keys(r).length>0&&(s.extras=r)}catch(r){console.warn("THREE.GLTFExporter: userData of '"+e.name+"' won't be serialized because of JSON.stringify error - "+r.message)}}getUID(e,s=!1){if(this.uids.has(e)===!1){const t=new Map;t.set(!0,this.uid++),t.set(!1,this.uid++),this.uids.set(e,t)}return this.uids.get(e).get(s)}isNormalizedNormalAttribute(e){if(this.cache.attributesNormalized.has(e))return!1;const i=new C;for(let t=0,r=e.count;t<r;t++)if(Math.abs(i.fromBufferAttribute(e,t).length()-1)>5e-4)return!1;return!0}createNormalizedNormalAttribute(e){const s=this.cache;if(s.attributesNormalized.has(e))return s.attributesNormalized.get(e);const i=e.clone(),t=new C;for(let r=0,n=i.count;r<n;r++)t.fromBufferAttribute(i,r),t.x===0&&t.y===0&&t.z===0?t.setX(1):t.normalize(),i.setXYZ(r,t.x,t.y,t.z);return s.attributesNormalized.set(e,i),i}applyTextureTransform(e,s){let i=!1;const t={};(s.offset.x!==0||s.offset.y!==0)&&(t.offset=s.offset.toArray(),i=!0),s.rotation!==0&&(t.rotation=s.rotation,i=!0),(s.repeat.x!==1||s.repeat.y!==1)&&(t.scale=s.repeat.toArray(),i=!0),i&&(e.extensions=e.extensions||{},e.extensions.KHR_texture_transform=t,this.extensionsUsed.KHR_texture_transform=!0)}async buildMetalRoughTextureAsync(e,s){if(e===s)return e;function i(f){return f.colorSpace===ye?function(g){return g<.04045?g*.0773993808:Math.pow(g*.9478672986+.0521327014,2.4)}:function(g){return g}}e instanceof j&&(e=await this.decompressTextureAsync(e)),s instanceof j&&(s=await this.decompressTextureAsync(s));const t=e?e.image:null,r=s?s.image:null,n=Math.max(t?t.width:0,r?r.width:0),o=Math.max(t?t.height:0,r?r.height:0),c=te();c.width=n,c.height=o;const l=c.getContext("2d",{willReadFrequently:!0});l.fillStyle="#00ffff",l.fillRect(0,0,n,o);const h=l.getImageData(0,0,n,o);if(t){l.drawImage(t,0,0,n,o);const f=i(e),p=l.getImageData(0,0,n,o).data;for(let g=2;g<p.length;g+=4)h.data[g]=f(p[g]/256)*256}if(r){l.drawImage(r,0,0,n,o);const f=i(s),p=l.getImageData(0,0,n,o).data;for(let g=1;g<p.length;g+=4)h.data[g]=f(p[g]/256)*256}l.putImageData(h,0,0);const w=(e||s).clone();return w.source=new he(c),w.colorSpace=de,w.channel=(e||s).channel,e&&s&&e.channel!==s.channel&&console.warn("THREE.GLTFExporter: UV channels for metalnessMap and roughnessMap textures must match."),console.warn("THREE.GLTFExporter: Merged metalnessMap and roughnessMap textures."),w}async decompressTextureAsync(e,s=1/0){if(this.textureUtils===null)throw new Error("THREE.GLTFExporter: setTextureUtils() must be called to process compressed textures.");return await this.textureUtils.decompress(e,s)}processBuffer(e){const s=this.json,i=this.buffers;return s.buffers||(s.buffers=[{byteLength:0}]),i.push(e),0}processBufferView(e,s,i,t,r){const n=this.json;n.bufferViews||(n.bufferViews=[]);let o;switch(s){case T.BYTE:case T.UNSIGNED_BYTE:o=1;break;case T.SHORT:case T.UNSIGNED_SHORT:o=2;break;default:o=4}let c=e.itemSize*o;r===T.ARRAY_BUFFER&&(c=Math.ceil(c/4)*4);const l=re(t*c),h=new DataView(new ArrayBuffer(l));let u=0;for(let p=i;p<i+t;p++){for(let g=0;g<e.itemSize;g++){let y;e.itemSize>4?y=e.array[p*e.itemSize+g]:(g===0?y=e.getX(p):g===1?y=e.getY(p):g===2?y=e.getZ(p):g===3&&(y=e.getW(p)),e.normalized===!0&&(y=q.normalize(y,e.array))),s===T.FLOAT?h.setFloat32(u,y,!0):s===T.INT?h.setInt32(u,y,!0):s===T.UNSIGNED_INT?h.setUint32(u,y,!0):s===T.SHORT?h.setInt16(u,y,!0):s===T.UNSIGNED_SHORT?h.setUint16(u,y,!0):s===T.BYTE?h.setInt8(u,y):s===T.UNSIGNED_BYTE&&h.setUint8(u,y),u+=o}u%c!==0&&(u+=c-u%c)}const w={buffer:this.processBuffer(h.buffer),byteOffset:this.byteOffset,byteLength:l};return r!==void 0&&(w.target=r),r===T.ARRAY_BUFFER&&(w.byteStride=c),this.byteOffset+=l,n.bufferViews.push(w),{id:n.bufferViews.length-1,byteLength:0}}processBufferViewImage(e){const s=this,i=s.json;return i.bufferViews||(i.bufferViews=[]),new Promise(function(t){const r=new FileReader;r.readAsArrayBuffer(e),r.onloadend=function(){const n=K(r.result),o={buffer:s.processBuffer(n),byteOffset:s.byteOffset,byteLength:n.byteLength};s.byteOffset+=n.byteLength,t(i.bufferViews.push(o)-1)}})}processAccessor(e,s,i,t){const r=this.json,n={1:"SCALAR",2:"VEC2",3:"VEC3",4:"VEC4",9:"MAT3",16:"MAT4"};let o;if(e.array.constructor===Float32Array)o=T.FLOAT;else if(e.array.constructor===Int32Array)o=T.INT;else if(e.array.constructor===Uint32Array)o=T.UNSIGNED_INT;else if(e.array.constructor===Int16Array)o=T.SHORT;else if(e.array.constructor===Uint16Array)o=T.UNSIGNED_SHORT;else if(e.array.constructor===Int8Array)o=T.BYTE;else if(e.array.constructor===Uint8Array)o=T.UNSIGNED_BYTE;else throw new Error("THREE.GLTFExporter: Unsupported bufferAttribute component type: "+e.array.constructor.name);if(i===void 0&&(i=0),(t===void 0||t===1/0)&&(t=e.count),t===0)return null;const c=os(e,i,t);let l;s!==void 0&&(l=e===s.index?T.ELEMENT_ARRAY_BUFFER:T.ARRAY_BUFFER);const h=this.processBufferView(e,o,i,t,l),u={bufferView:h.id,byteOffset:h.byteOffset,componentType:o,count:t,max:c.max,min:c.min,type:n[e.itemSize]};return e.normalized===!0&&(u.normalized=!0),r.accessors||(r.accessors=[]),r.accessors.push(u)-1}processImage(e,s,i,t="image/png"){if(e!==null){const r=this,n=r.cache,o=r.json,c=r.options,l=r.pending;n.images.has(e)||n.images.set(e,{});const h=n.images.get(e),u=t+":flipY/"+i.toString();if(h[u]!==void 0)return h[u];o.images||(o.images=[]);const w={mimeType:t},f=te();f.width=Math.min(e.width,c.maxTextureSize),f.height=Math.min(e.height,c.maxTextureSize);const p=f.getContext("2d",{willReadFrequently:!0});if(i===!0&&(p.translate(0,f.height),p.scale(1,-1)),e.data!==void 0){s!==pe&&console.error("GLTFExporter: Only RGBAFormat is supported.",s),(e.width>c.maxTextureSize||e.height>c.maxTextureSize)&&console.warn("GLTFExporter: Image size is bigger than maxTextureSize",e);const y=new Uint8ClampedArray(e.height*e.width*4);for(let x=0;x<y.length;x+=4)y[x+0]=e.data[x+0],y[x+1]=e.data[x+1],y[x+2]=e.data[x+2],y[x+3]=e.data[x+3];p.putImageData(new ImageData(y,e.width,e.height),0,0)}else if(typeof HTMLImageElement<"u"&&e instanceof HTMLImageElement||typeof HTMLCanvasElement<"u"&&e instanceof HTMLCanvasElement||typeof ImageBitmap<"u"&&e instanceof ImageBitmap||typeof OffscreenCanvas<"u"&&e instanceof OffscreenCanvas)p.drawImage(e,0,0,f.width,f.height);else throw new Error("THREE.GLTFExporter: Invalid image type. Use HTMLImageElement, HTMLCanvasElement, ImageBitmap or OffscreenCanvas.");c.binary===!0?l.push(ne(f,t).then(y=>r.processBufferViewImage(y)).then(y=>{w.bufferView=y})):f.toDataURL!==void 0?w.uri=f.toDataURL(t):l.push(ne(f,t).then(y=>new FileReader().readAsDataURL(y)).then(y=>{w.uri=y}));const g=o.images.push(w)-1;return h[u]=g,g}else throw new Error("THREE.GLTFExporter: No valid image data found. Unable to process texture.")}processSampler(e){const s=this.json;s.samplers||(s.samplers=[]);const i={magFilter:L[e.magFilter],minFilter:L[e.minFilter],wrapS:L[e.wrapS],wrapT:L[e.wrapT]};return s.samplers.push(i)-1}async processTextureAsync(e){const i=this.options,t=this.cache,r=this.json;if(t.textures.has(e))return t.textures.get(e);r.textures||(r.textures=[]),e instanceof j&&(e=await this.decompressTextureAsync(e,i.maxTextureSize));let n=e.userData.mimeType;n==="image/webp"&&(n="image/png");const o={sampler:this.processSampler(e),source:this.processImage(e.image,e.format,e.flipY,n)};e.name&&(o.name=e.name),await this._invokeAllAsync(async function(l){l.writeTexture&&await l.writeTexture(e,o)});const c=r.textures.push(o)-1;return t.textures.set(e,c),c}async processMaterialAsync(e){const s=this.cache,i=this.json;if(s.materials.has(e))return s.materials.get(e);if(e.isShaderMaterial)return console.warn("GLTFExporter: THREE.ShaderMaterial not supported."),null;i.materials||(i.materials=[]);const t={pbrMetallicRoughness:{}};e.isMeshStandardMaterial!==!0&&e.isMeshBasicMaterial!==!0&&console.warn("GLTFExporter: Use MeshStandardMaterial or MeshBasicMaterial for best results.");const r=e.color.toArray().concat([e.opacity]);if(D(r,[1,1,1,1])||(t.pbrMetallicRoughness.baseColorFactor=r),e.isMeshStandardMaterial?(t.pbrMetallicRoughness.metallicFactor=e.metalness,t.pbrMetallicRoughness.roughnessFactor=e.roughness):(t.pbrMetallicRoughness.metallicFactor=0,t.pbrMetallicRoughness.roughnessFactor=1),e.metalnessMap||e.roughnessMap){const o=await this.buildMetalRoughTextureAsync(e.metalnessMap,e.roughnessMap),c={index:await this.processTextureAsync(o),texCoord:o.channel};this.applyTextureTransform(c,o),t.pbrMetallicRoughness.metallicRoughnessTexture=c}if(e.map){const o={index:await this.processTextureAsync(e.map),texCoord:e.map.channel};this.applyTextureTransform(o,e.map),t.pbrMetallicRoughness.baseColorTexture=o}if(e.emissive){const o=e.emissive;if(Math.max(o.r,o.g,o.b)>0&&(t.emissiveFactor=e.emissive.toArray()),e.emissiveMap){const l={index:await this.processTextureAsync(e.emissiveMap),texCoord:e.emissiveMap.channel};this.applyTextureTransform(l,e.emissiveMap),t.emissiveTexture=l}}if(e.normalMap){const o={index:await this.processTextureAsync(e.normalMap),texCoord:e.normalMap.channel};e.normalScale&&e.normalScale.x!==1&&(o.scale=e.normalScale.x),this.applyTextureTransform(o,e.normalMap),t.normalTexture=o}if(e.aoMap){const o={index:await this.processTextureAsync(e.aoMap),texCoord:e.aoMap.channel};e.aoMapIntensity!==1&&(o.strength=e.aoMapIntensity),this.applyTextureTransform(o,e.aoMap),t.occlusionTexture=o}e.transparent?t.alphaMode="BLEND":e.alphaTest>0&&(t.alphaMode="MASK",t.alphaCutoff=e.alphaTest),e.side===ge&&(t.doubleSided=!0),e.name!==""&&(t.name=e.name),this.serializeUserData(e,t),await this._invokeAllAsync(async function(o){o.writeMaterialAsync&&await o.writeMaterialAsync(e,t)});const n=i.materials.push(t)-1;return s.materials.set(e,n),n}async processMeshAsync(e){const s=this.cache,i=this.json,t=[e.geometry.uuid];if(Array.isArray(e.material))for(let d=0,m=e.material.length;d<m;d++)t.push(e.material[d].uuid);else t.push(e.material.uuid);const r=t.join(":");if(s.meshes.has(r))return s.meshes.get(r);const n=e.geometry;let o;e.isLineSegments?o=T.LINES:e.isLineLoop?o=T.LINE_LOOP:e.isLine?o=T.LINE_STRIP:e.isPoints?o=T.POINTS:o=e.material.wireframe?T.LINES:T.TRIANGLES;const c={},l={},h=[],u=[],w={uv:"TEXCOORD_0",uv1:"TEXCOORD_1",uv2:"TEXCOORD_2",uv3:"TEXCOORD_3",color:"COLOR_0",skinWeight:"WEIGHTS_0",skinIndex:"JOINTS_0"},f=n.getAttribute("normal");f!==void 0&&!this.isNormalizedNormalAttribute(f)&&(console.warn("THREE.GLTFExporter: Creating normalized normal attribute from the non-normalized one."),n.setAttribute("normal",this.createNormalizedNormalAttribute(f)));let p=null;for(let d in n.attributes){if(d.slice(0,5)==="morph")continue;const m=n.attributes[d];if(d=w[d]||d.toUpperCase(),/^(POSITION|NORMAL|TANGENT|TEXCOORD_\d+|COLOR_\d+|JOINTS_\d+|WEIGHTS_\d+)$/.test(d)||(d="_"+d),s.attributes.has(this.getUID(m))){l[d]=s.attributes.get(this.getUID(m));continue}p=null;const I=m.array;d==="JOINTS_0"&&!(I instanceof Uint16Array)&&!(I instanceof Uint8Array)?(console.warn('GLTFExporter: Attribute "skinIndex" converted to type UNSIGNED_SHORT.'),p=new _(new Uint16Array(I),m.itemSize,m.normalized)):(I instanceof Uint32Array||I instanceof Int32Array)&&!d.startsWith("_")&&(console.warn(`GLTFExporter: Attribute "${d}" converted to type FLOAT.`),p=k.Utils.toFloat32BufferAttribute(m));const b=this.processAccessor(p||m,n);b!==null&&(d.startsWith("_")||this.detectMeshQuantization(d,m),l[d]=b,s.attributes.set(this.getUID(m),b))}if(f!==void 0&&n.setAttribute("normal",f),Object.keys(l).length===0)return null;if(e.morphTargetInfluences!==void 0&&e.morphTargetInfluences.length>0){const d=[],m=[],A={};if(e.morphTargetDictionary!==void 0)for(const I in e.morphTargetDictionary)A[e.morphTargetDictionary[I]]=I;for(let I=0;I<e.morphTargetInfluences.length;++I){const b={};let W=!1;for(const v in n.morphAttributes){if(v!=="position"&&v!=="normal"){W||(console.warn("GLTFExporter: Only POSITION and NORMAL morph are supported."),W=!0);continue}const S=n.morphAttributes[v][I],H=v.toUpperCase(),F=n.attributes[v];if(s.attributes.has(this.getUID(S,!0))){b[H]=s.attributes.get(this.getUID(S,!0));continue}const O=S.clone();if(!n.morphTargetsRelative)for(let R=0,oe=S.count;R<oe;R++)for(let U=0;U<S.itemSize;U++)U===0&&O.setX(R,S.getX(R)-F.getX(R)),U===1&&O.setY(R,S.getY(R)-F.getY(R)),U===2&&O.setZ(R,S.getZ(R)-F.getZ(R)),U===3&&O.setW(R,S.getW(R)-F.getW(R));b[H]=this.processAccessor(O,n),s.attributes.set(this.getUID(F,!0),b[H])}u.push(b),d.push(e.morphTargetInfluences[I]),e.morphTargetDictionary!==void 0&&m.push(A[I])}c.weights=d,m.length>0&&(c.extras={},c.extras.targetNames=m)}const g=Array.isArray(e.material);if(g&&n.groups.length===0)return null;let y=!1;if(g&&n.index===null){const d=[];for(let m=0,A=n.attributes.position.count;m<A;m++)d[m]=m;n.setIndex(d),y=!0}const x=g?e.material:[e.material],M=g?n.groups:[{materialIndex:0,start:void 0,count:void 0}];for(let d=0,m=M.length;d<m;d++){const A={mode:o,attributes:l};if(this.serializeUserData(n,A),u.length>0&&(A.targets=u),n.index!==null){let b=this.getUID(n.index);(M[d].start!==void 0||M[d].count!==void 0)&&(b+=":"+M[d].start+":"+M[d].count),s.attributes.has(b)?A.indices=s.attributes.get(b):(A.indices=this.processAccessor(n.index,n,M[d].start,M[d].count),s.attributes.set(b,A.indices)),A.indices===null&&delete A.indices}const I=await this.processMaterialAsync(x[M[d].materialIndex]);I!==null&&(A.material=I),h.push(A)}y===!0&&n.setIndex(null),c.primitives=h,i.meshes||(i.meshes=[]),await this._invokeAllAsync(function(d){d.writeMesh&&d.writeMesh(e,c)});const E=i.meshes.push(c)-1;return s.meshes.set(r,E),E}detectMeshQuantization(e,s){if(this.extensionsUsed[Y])return;let i;switch(s.array.constructor){case Int8Array:i="byte";break;case Uint8Array:i="unsigned byte";break;case Int16Array:i="short";break;case Uint16Array:i="unsigned short";break;default:return}s.normalized&&(i+=" normalized");const t=e.split("_",1)[0];Q[t]&&Q[t].includes(i)&&(this.extensionsUsed[Y]=!0,this.extensionsRequired[Y]=!0)}processCamera(e){const s=this.json;s.cameras||(s.cameras=[]);const i=e.isOrthographicCamera,t={type:i?"orthographic":"perspective"};return i?t.orthographic={xmag:e.right*2,ymag:e.top*2,zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near}:t.perspective={aspectRatio:e.aspect,yfov:q.degToRad(e.fov),zfar:e.far<=0?.001:e.far,znear:e.near<0?0:e.near},e.name!==""&&(t.name=e.type),s.cameras.push(t)-1}processAnimation(e,s){const i=this.json,t=this.nodeMap;i.animations||(i.animations=[]),e=k.Utils.mergeMorphTargetTracks(e.clone(),s);const r=e.tracks,n=[],o=[];for(let c=0;c<r.length;++c){const l=r[c],h=P.parseTrackName(l.name);let u=P.findNode(s,h.nodeName);const w=$[h.propertyName];if(h.objectName==="bones"&&(u.isSkinnedMesh===!0?u=u.skeleton.getBoneByName(h.objectIndex):u=void 0),!u||!w){console.warn('THREE.GLTFExporter: Could not export animation track "%s".',l.name);continue}const f=1;let p=l.values.length/l.times.length;w===$.morphTargetInfluences&&(p/=u.morphTargetInfluences.length);let g;l.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline===!0?(g="CUBICSPLINE",p/=3):l.getInterpolation()===xe?g="STEP":g="LINEAR",o.push({input:this.processAccessor(new _(l.times,f)),output:this.processAccessor(new _(l.values,p)),interpolation:g}),n.push({sampler:o.length-1,target:{node:t.get(u),path:w}})}return i.animations.push({name:e.name||"clip_"+i.animations.length,samplers:o,channels:n}),i.animations.length-1}processSkin(e){const s=this.json,i=this.nodeMap,t=s.nodes[i.get(e)],r=e.skeleton;if(r===void 0)return null;const n=e.skeleton.bones[0];if(n===void 0)return null;const o=[],c=new Float32Array(r.bones.length*16),l=new ie;for(let u=0;u<r.bones.length;++u)o.push(i.get(r.bones[u])),l.copy(r.boneInverses[u]),l.multiply(e.bindMatrix).toArray(c,u*16);return s.skins===void 0&&(s.skins=[]),s.skins.push({inverseBindMatrices:this.processAccessor(new _(c,16)),joints:o,skeleton:i.get(n)}),t.skin=s.skins.length-1}async processNodeAsync(e){const s=this.json,i=this.options,t=this.nodeMap;s.nodes||(s.nodes=[]);const r={};if(i.trs){const o=e.quaternion.toArray(),c=e.position.toArray(),l=e.scale.toArray();D(o,[0,0,0,1])||(r.rotation=o),D(c,[0,0,0])||(r.translation=c),D(l,[1,1,1])||(r.scale=l)}else e.matrixAutoUpdate&&e.updateMatrix(),rs(e.matrix)===!1&&(r.matrix=e.matrix.elements);if(e.name!==""&&(r.name=String(e.name)),this.serializeUserData(e,r),e.isMesh||e.isLine||e.isPoints){const o=await this.processMeshAsync(e);o!==null&&(r.mesh=o)}else e.isCamera&&(r.camera=this.processCamera(e));if(e.isSkinnedMesh&&this.skins.push(e),e.children.length>0){const o=[];for(let c=0,l=e.children.length;c<l;c++){const h=e.children[c];if(h.visible||i.onlyVisible===!1){const u=await this.processNodeAsync(h);u!==null&&o.push(u)}}o.length>0&&(r.children=o)}await this._invokeAllAsync(function(o){o.writeNode&&o.writeNode(e,r)});const n=s.nodes.push(r)-1;return t.set(e,n),n}async processSceneAsync(e){const s=this.json,i=this.options;s.scenes||(s.scenes=[],s.scene=0);const t={};e.name!==""&&(t.name=e.name),s.scenes.push(t);const r=[];for(let n=0,o=e.children.length;n<o;n++){const c=e.children[n];if(c.visible||i.onlyVisible===!1){const l=await this.processNodeAsync(c);l!==null&&r.push(l)}}r.length>0&&(t.nodes=r),this.serializeUserData(e,t)}async processObjectsAsync(e){const s=new X;s.name="AuxScene";for(let i=0;i<e.length;i++)s.children.push(e[i]);await this.processSceneAsync(s)}async processInputAsync(e){const s=this.options;e=e instanceof Array?e:[e],await this._invokeAllAsync(function(t){t.beforeParse&&t.beforeParse(e)});const i=[];for(let t=0;t<e.length;t++)e[t]instanceof X?await this.processSceneAsync(e[t]):i.push(e[t]);i.length>0&&await this.processObjectsAsync(i);for(let t=0;t<this.skins.length;++t)this.processSkin(this.skins[t]);for(let t=0;t<s.animations.length;++t)this.processAnimation(s.animations[t],e[0]);await this._invokeAllAsync(function(t){t.afterParse&&t.afterParse(e)})}async _invokeAllAsync(e){for(let s=0,i=this.plugins.length;s<i;s++)await e(this.plugins[s])}}class cs{constructor(e){this.writer=e,this.name="KHR_lights_punctual"}writeNode(e,s){if(!e.isLight)return;if(!e.isDirectionalLight&&!e.isPointLight&&!e.isSpotLight){console.warn("THREE.GLTFExporter: Only directional, point, and spot lights are supported.",e);return}const i=this.writer,t=i.json,r=i.extensionsUsed,n={};e.name&&(n.name=e.name),n.color=e.color.toArray(),n.intensity=e.intensity,e.isDirectionalLight?n.type="directional":e.isPointLight?(n.type="point",e.distance>0&&(n.range=e.distance)):e.isSpotLight&&(n.type="spot",e.distance>0&&(n.range=e.distance),n.spot={},n.spot.innerConeAngle=(1-e.penumbra)*e.angle,n.spot.outerConeAngle=e.angle),e.decay!==void 0&&e.decay!==2&&console.warn("THREE.GLTFExporter: Light decay may be lost. glTF is physically-based, and expects light.decay=2."),e.target&&(e.target.parent!==e||e.target.position.x!==0||e.target.position.y!==0||e.target.position.z!==-1)&&console.warn("THREE.GLTFExporter: Light direction may be lost. For best results, make light.target a child of the light with position 0,0,-1."),r[this.name]||(t.extensions=t.extensions||{},t.extensions[this.name]={lights:[]},r[this.name]=!0);const o=t.extensions[this.name].lights;o.push(n),s.extensions=s.extensions||{},s.extensions[this.name]={light:o.length-1}}}class ls{constructor(e){this.writer=e,this.name="KHR_materials_unlit"}async writeMaterialAsync(e,s){if(!e.isMeshBasicMaterial)return;const t=this.writer.extensionsUsed;s.extensions=s.extensions||{},s.extensions[this.name]={},t[this.name]=!0,s.pbrMetallicRoughness.metallicFactor=0,s.pbrMetallicRoughness.roughnessFactor=.9}}class us{constructor(e){this.writer=e,this.name="KHR_materials_clearcoat"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.clearcoat===0)return;const i=this.writer,t=i.extensionsUsed,r={};if(r.clearcoatFactor=e.clearcoat,e.clearcoatMap){const n={index:await i.processTextureAsync(e.clearcoatMap),texCoord:e.clearcoatMap.channel};i.applyTextureTransform(n,e.clearcoatMap),r.clearcoatTexture=n}if(r.clearcoatRoughnessFactor=e.clearcoatRoughness,e.clearcoatRoughnessMap){const n={index:await i.processTextureAsync(e.clearcoatRoughnessMap),texCoord:e.clearcoatRoughnessMap.channel};i.applyTextureTransform(n,e.clearcoatRoughnessMap),r.clearcoatRoughnessTexture=n}if(e.clearcoatNormalMap){const n={index:await i.processTextureAsync(e.clearcoatNormalMap),texCoord:e.clearcoatNormalMap.channel};e.clearcoatNormalScale.x!==1&&(n.scale=e.clearcoatNormalScale.x),i.applyTextureTransform(n,e.clearcoatNormalMap),r.clearcoatNormalTexture=n}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class fs{constructor(e){this.writer=e,this.name="KHR_materials_dispersion"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.dispersion===0)return;const t=this.writer.extensionsUsed,r={};r.dispersion=e.dispersion,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class hs{constructor(e){this.writer=e,this.name="KHR_materials_iridescence"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.iridescence===0)return;const i=this.writer,t=i.extensionsUsed,r={};if(r.iridescenceFactor=e.iridescence,e.iridescenceMap){const n={index:await i.processTextureAsync(e.iridescenceMap),texCoord:e.iridescenceMap.channel};i.applyTextureTransform(n,e.iridescenceMap),r.iridescenceTexture=n}if(r.iridescenceIor=e.iridescenceIOR,r.iridescenceThicknessMinimum=e.iridescenceThicknessRange[0],r.iridescenceThicknessMaximum=e.iridescenceThicknessRange[1],e.iridescenceThicknessMap){const n={index:await i.processTextureAsync(e.iridescenceThicknessMap),texCoord:e.iridescenceThicknessMap.channel};i.applyTextureTransform(n,e.iridescenceThicknessMap),r.iridescenceThicknessTexture=n}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class ds{constructor(e){this.writer=e,this.name="KHR_materials_transmission"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const i=this.writer,t=i.extensionsUsed,r={};if(r.transmissionFactor=e.transmission,e.transmissionMap){const n={index:await i.processTextureAsync(e.transmissionMap),texCoord:e.transmissionMap.channel};i.applyTextureTransform(n,e.transmissionMap),r.transmissionTexture=n}s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class ps{constructor(e){this.writer=e,this.name="KHR_materials_volume"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.transmission===0)return;const i=this.writer,t=i.extensionsUsed,r={};if(r.thicknessFactor=e.thickness,e.thicknessMap){const n={index:await i.processTextureAsync(e.thicknessMap),texCoord:e.thicknessMap.channel};i.applyTextureTransform(n,e.thicknessMap),r.thicknessTexture=n}e.attenuationDistance!==1/0&&(r.attenuationDistance=e.attenuationDistance),r.attenuationColor=e.attenuationColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class gs{constructor(e){this.writer=e,this.name="KHR_materials_ior"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.ior===1.5)return;const t=this.writer.extensionsUsed,r={};r.ior=e.ior,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class xs{constructor(e){this.writer=e,this.name="KHR_materials_specular"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.specularIntensity===1&&e.specularColor.equals($e)&&!e.specularIntensityMap&&!e.specularColorMap)return;const i=this.writer,t=i.extensionsUsed,r={};if(e.specularIntensityMap){const n={index:await i.processTextureAsync(e.specularIntensityMap),texCoord:e.specularIntensityMap.channel};i.applyTextureTransform(n,e.specularIntensityMap),r.specularTexture=n}if(e.specularColorMap){const n={index:await i.processTextureAsync(e.specularColorMap),texCoord:e.specularColorMap.channel};i.applyTextureTransform(n,e.specularColorMap),r.specularColorTexture=n}r.specularFactor=e.specularIntensity,r.specularColorFactor=e.specularColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class ys{constructor(e){this.writer=e,this.name="KHR_materials_sheen"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.sheen==0)return;const i=this.writer,t=i.extensionsUsed,r={};if(e.sheenRoughnessMap){const n={index:await i.processTextureAsync(e.sheenRoughnessMap),texCoord:e.sheenRoughnessMap.channel};i.applyTextureTransform(n,e.sheenRoughnessMap),r.sheenRoughnessTexture=n}if(e.sheenColorMap){const n={index:await i.processTextureAsync(e.sheenColorMap),texCoord:e.sheenColorMap.channel};i.applyTextureTransform(n,e.sheenColorMap),r.sheenColorTexture=n}r.sheenRoughnessFactor=e.sheenRoughness,r.sheenColorFactor=e.sheenColor.toArray(),s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class ms{constructor(e){this.writer=e,this.name="KHR_materials_anisotropy"}async writeMaterialAsync(e,s){if(!e.isMeshPhysicalMaterial||e.anisotropy==0)return;const i=this.writer,t=i.extensionsUsed,r={};if(e.anisotropyMap){const n={index:await i.processTextureAsync(e.anisotropyMap)};i.applyTextureTransform(n,e.anisotropyMap),r.anisotropyTexture=n}r.anisotropyStrength=e.anisotropy,r.anisotropyRotation=e.anisotropyRotation,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Ts{constructor(e){this.writer=e,this.name="KHR_materials_emissive_strength"}async writeMaterialAsync(e,s){if(!e.isMeshStandardMaterial||e.emissiveIntensity===1)return;const t=this.writer.extensionsUsed,r={};r.emissiveStrength=e.emissiveIntensity,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class ws{constructor(e){this.writer=e,this.name="EXT_materials_bump"}async writeMaterialAsync(e,s){if(!e.isMeshStandardMaterial||e.bumpScale===1&&!e.bumpMap)return;const i=this.writer,t=i.extensionsUsed,r={};if(e.bumpMap){const n={index:await i.processTextureAsync(e.bumpMap),texCoord:e.bumpMap.channel};i.applyTextureTransform(n,e.bumpMap),r.bumpTexture=n}r.bumpFactor=e.bumpScale,s.extensions=s.extensions||{},s.extensions[this.name]=r,t[this.name]=!0}}class Ms{constructor(e){this.writer=e,this.name="EXT_mesh_gpu_instancing"}writeNode(e,s){if(!e.isInstancedMesh)return;const i=this.writer,t=e,r=new Float32Array(t.count*3),n=new Float32Array(t.count*4),o=new Float32Array(t.count*3),c=new ie,l=new C,h=new ue,u=new C;for(let f=0;f<t.count;f++)t.getMatrixAt(f,c),c.decompose(l,h,u),l.toArray(r,f*3),h.toArray(n,f*4),u.toArray(o,f*3);const w={TRANSLATION:i.processAccessor(new _(r,3)),ROTATION:i.processAccessor(new _(n,4)),SCALE:i.processAccessor(new _(o,3))};t.instanceColor&&(w._COLOR_0=i.processAccessor(t.instanceColor)),s.extensions=s.extensions||{},s.extensions[this.name]={attributes:w},i.extensionsUsed[this.name]=!0,i.extensionsRequired[this.name]=!0}}k.Utils={insertKeyframe:function(a,e){const i=a.getValueSize(),t=new a.TimeBufferType(a.times.length+1),r=new a.ValueBufferType(a.values.length+i),n=a.createInterpolant(new a.ValueBufferType(i));let o;if(a.times.length===0){t[0]=e;for(let c=0;c<i;c++)r[c]=0;o=0}else if(e<a.times[0]){if(Math.abs(a.times[0]-e)<.001)return 0;t[0]=e,t.set(a.times,1),r.set(n.evaluate(e),0),r.set(a.values,i),o=0}else if(e>a.times[a.times.length-1]){if(Math.abs(a.times[a.times.length-1]-e)<.001)return a.times.length-1;t[t.length-1]=e,t.set(a.times,0),r.set(a.values,0),r.set(n.evaluate(e),a.values.length),o=t.length-1}else for(let c=0;c<a.times.length;c++){if(Math.abs(a.times[c]-e)<.001)return c;if(a.times[c]<e&&a.times[c+1]>e){t.set(a.times.slice(0,c+1),0),t[c+1]=e,t.set(a.times.slice(c+1),c+2),r.set(a.values.slice(0,(c+1)*i),0),r.set(n.evaluate(e),(c+1)*i),r.set(a.values.slice((c+1)*i),(c+2)*i),o=c+1;break}}return a.times=t,a.values=r,o},mergeMorphTargetTracks:function(a,e){const s=[],i={},t=a.tracks;for(let r=0;r<t.length;++r){let n=t[r];const o=P.parseTrackName(n.name),c=P.findNode(e,o.nodeName);if(o.propertyName!=="morphTargetInfluences"||o.propertyIndex===void 0){s.push(n);continue}if(n.createInterpolant!==n.InterpolantFactoryMethodDiscrete&&n.createInterpolant!==n.InterpolantFactoryMethodLinear){if(n.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline)throw new Error("THREE.GLTFExporter: Cannot merge tracks with glTF CUBICSPLINE interpolation.");console.warn("THREE.GLTFExporter: Morph target interpolation mode not yet supported. Using LINEAR instead."),n=n.clone(),n.setInterpolation(Le)}const l=c.morphTargetInfluences.length,h=c.morphTargetDictionary[o.propertyIndex];if(h===void 0)throw new Error("THREE.GLTFExporter: Morph target name not found: "+o.propertyIndex);let u;if(i[c.uuid]===void 0){u=n.clone();const f=new u.ValueBufferType(l*u.times.length);for(let p=0;p<u.times.length;p++)f[p*l+h]=u.values[p];u.name=(o.nodeName||"")+".morphTargetInfluences",u.values=f,i[c.uuid]=u,s.push(u);continue}const w=n.createInterpolant(new n.ValueBufferType(1));u=i[c.uuid];for(let f=0;f<u.times.length;f++)u.values[f*l+h]=w.evaluate(u.times[f]);for(let f=0;f<n.times.length;f++){const p=this.insertKeyframe(u,n.times[f]);u.values[p*l+h]=n.values[f]}}return a.tracks=s,a},toFloat32BufferAttribute:function(a){const e=new _(new Float32Array(a.count*a.itemSize),a.itemSize,!1);if(!a.normalized&&!a.isInterleavedBufferAttribute)return e.array.set(a.array),e;for(let s=0,i=a.count;s<i;s++)for(let t=0;t<a.itemSize;t++)e.setComponent(s,t,a.getComponent(s,t));return e}};class As{constructor(e){V(this,"map");V(this,"loader",new Ne);this.map=e,this.loader.responseType="json"}getUrl(e){return`https://tubvsig-so2sat-vm1.srv.mwn.de/geoserver/ows?service=WFS&version=2.0.0&request=GetFeature&typeNames=global3D:lod1_global&outputFormat=application/json&srsName=EPSG:4326&bbox=${e.join(",")},EPSG:4326`}async load(e,s){typeof e!="string"&&(e=this.getUrl(e));const i=await this.loader.loadAsync(e,s);console.time("createBuildingGeometry");const t=this.CreateBuilding(i);return console.timeEnd("createBuildingGeometry"),t}CreateBuilding(e){const s=new Array;e.features.forEach(t=>{const r=t.geometry,n=r.type;(n==="Polygon"?[r.coordinates]:n==="MultiPolygon"?r.coordinates:[]).forEach(c=>{var h;const l=this.createBuildingGeometry(c,(h=t.properties)==null?void 0:h.height);s.push(l)})});const i=qe(s,!1);return i.computeVertexNormals(),i}createBuildingGeometry(e,s=0){const i=new Se;return e.forEach((r,n)=>{const o=r.map(c=>{const[l,h]=this.map.geo2map(new C(c[0],c[1],0));return new _e(l,h)});if(n===0)i.setFromPoints(o);else{const c=new Ce(o);i.holes.push(c)}}),new Ue(i,{depth:s,bevelThickness:1})}}const Es={class:"demo-container"},Is={class:"state"},Rs={class:"location"},bs={class:"loading"},Ls={key:0,id:"model-loading"},Ns=We({__name:"GeoJSON3D",setup(a){const e=()=>{const x=De.create({imgSource:[new ze],lon0:90,bounds:[60,0,145,60]});return x.rotateX(-Math.PI/2),x},s=(x,M,E,d)=>{x.controls.target.copy(M.geo2world(E)),x.camera.position.copy(M.geo2world(d)),x.dirLight.target.position.copy(x.controls.target),x.dirLight.position.copy(x.controls.target),x.dirLight.position.add(new C(0,6e3,-1e4));const m=new Pe(x.dirLight,1e3);x.scene.add(m)},i=B(null),t=B(),r=B(),n=e(),o=new ve(void 0,{antialias:!0});o.renderer.toneMapping=Fe,o.dirLight.intensity=3,Ke(o.scene);const c=He(n,o),l=Ve(n),h=B("");je(o.controls,t);const u=B(),w=Ye(u);o.addEventListener("update",()=>{w.update()});const f=[108.92,34.2524,108.9675,34.2783];Xe(()=>{if(!i.value){console.error("map or cssrenderer or compass container is null");return}o.addTo(i.value),o.scene.add(n);const x=new C((f[0]+f[2])/2,(f[1]+f[3])/2,0);s(o,n,x,new C(x.x,x.y,1e5)),n.addEventListener("update",()=>{Oe(n,o.camera)}),p()}),Je(()=>{n.dispose()});const p=async x=>{h.value="Loading...";const d=await new As(n).load("../../map/building-4236.geojson",m=>{h.value=`加载中: ${m.loaded.toLocaleString("en-US")} Bytes `}).catch(m=>(console.error("加载建筑模型失败:",m),h.value="模型加载失败",null));if(console.log("数据加载完成"),d){h.value="";const m=new Be({color:34816,metalness:.6,roughness:.6,emissiveIntensity:.5}),A=new Ge(d,m);A.name="building",A.scale.setZ(3),n.add(A),o.flyToObject(A),r.value&&y(A)}},g={exportBuilding:()=>{const x=n.getObjectByName("building");x&&new k().parse(x,E=>{const d=new Blob([E],{type:"model/gltf-binary"}),m=document.createElement("a");m.href=URL.createObjectURL(d),m.download="building.glb",m.click()},E=>{console.error("导出GLTF模型失败:",E)},{binary:!0,onlyVisible:!0})}},y=x=>{const M=new ke({container:r.value,autoPlace:!1});M.addColor(o.scene.fog,"color").name("雾颜色"),M.add(o,"fogFactor",0,5,.01).name("雾浓度"),M.add(o.ambLight,"intensity",0,10,.01).name("环境光强度"),M.add(o.dirLight,"intensity",0,10,.01).name("直射光强度");const E=x.material;M.add(x,"visible").name("建筑物显示/隐藏"),M.add(E,"wireframe").name("线框"),M.addColor(E,"color").name("建筑颜色"),M.add(E,"metalness",0,1,.01).name("金属度"),M.add(E,"roughness",0,1,.01).name("粗糙度"),M.addColor(E,"emissive").name("自发光"),M.add(E,"emissiveIntensity",0,1,.01).name("自发光强度"),M.add(x.scale,"z",1,10).name("建筑物拉伸"),M.add(g,"exportBuilding").name("导出建筑模型")};return(x,M)=>(Z(),J("div",Es,[N("div",{ref_key:"viewerRef",ref:i,class:"map-container"},null,512),N("div",{class:"compass",ref_key:"compassRef",ref:t},null,512),N("div",Is,[N("div",Rs,[N("span",null,"经度："+G(z(c).x.toFixed(6))+"° ",1),N("span",null,"纬度："+G(z(c).y.toFixed(6))+"° ",1),N("span",null,"海拔："+G(z(c).z.toFixed(1))+"m ",1)]),N("div",bs,G(z(l)),1)]),N("div",{class:"stats",ref_key:"statsRef",ref:u},null,512),N("div",{class:"gui",ref_key:"guiRef",ref:r},null,512),h.value?(Z(),J("div",Ls,G(h.value),1)):Ze("",!0)]))}}),Gs=Qe(Ns,[["__scopeId","data-v-a8be9c35"]]);export{Gs as default};
