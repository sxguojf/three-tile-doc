import{L as N,F as M,j as P,i as K,K as B,p as O,b as V,ac as j,ax as z,D as H,V as T,Q as q,ah as Q,ai as Y,ay as Z,ak as X,az as J,M as $}from"./index.D-Y8yZZR.js";import{a as ee,b as te,u as oe}from"./style.RbGHg-Vc.js";import{u as se}from"./useSky.D-YiwE1J.js";import{u as re}from"./useState.BDVbIXbi.js";import{G as ne}from"./GLTFLoader.CkiCWgjt.js";import{v as F,x as W,d as ae,p as x,c as ie,o as ce,j as w,a as de,t as S,k as D,_ as le}from"./framework.CJqd0DOR.js";const I=new WeakMap;class ue extends N{constructor(e){super(e),this.decoderPath="",this.decoderConfig={},this.decoderBinary=null,this.decoderPending=null,this.workerLimit=4,this.workerPool=[],this.workerNextTaskID=1,this.workerSourceURL="",this.defaultAttributeIDs={position:"POSITION",normal:"NORMAL",color:"COLOR",uv:"TEX_COORD"},this.defaultAttributeTypes={position:"Float32Array",normal:"Float32Array",color:"Float32Array",uv:"Float32Array"}}setDecoderPath(e){return this.decoderPath=e,this}setDecoderConfig(e){return this.decoderConfig=e,this}setWorkerLimit(e){return this.workerLimit=e,this}load(e,r,s,t){const n=new M(this.manager);n.setPath(this.path),n.setResponseType("arraybuffer"),n.setRequestHeader(this.requestHeader),n.setWithCredentials(this.withCredentials),n.load(e,o=>{this.parse(o,r,t)},s,t)}parse(e,r,s=()=>{}){this.decodeDracoFile(e,r,null,null,P,s).catch(s)}decodeDracoFile(e,r,s,t,n=K,o=()=>{}){const a={attributeIDs:s||this.defaultAttributeIDs,attributeTypes:t||this.defaultAttributeTypes,useUniqueIDs:!!s,vertexColorSpace:n};return this.decodeGeometry(e,a).then(r).catch(o)}decodeGeometry(e,r){const s=JSON.stringify(r);if(I.has(e)){const i=I.get(e);if(i.key===s)return i.promise;if(e.byteLength===0)throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")}let t;const n=this.workerNextTaskID++,o=e.byteLength,a=this._getWorker(n,o).then(i=>(t=i,new Promise((f,u)=>{t._callbacks[n]={resolve:f,reject:u},t.postMessage({type:"decode",id:n,taskConfig:r,buffer:e},[e])}))).then(i=>this._createGeometry(i.geometry));return a.catch(()=>!0).then(()=>{t&&n&&this._releaseTask(t,n)}),I.set(e,{key:s,promise:a}),a}_createGeometry(e){const r=new B;e.index&&r.setIndex(new O(e.index.array,1));for(let s=0;s<e.attributes.length;s++){const t=e.attributes[s],n=t.name,o=t.array,a=t.itemSize,i=new O(o,a);n==="color"&&(this._assignVertexColorSpace(i,t.vertexColorSpace),i.normalized=!(o instanceof Float32Array)),r.setAttribute(n,i)}return r}_assignVertexColorSpace(e,r){if(r!==P)return;const s=new V;for(let t=0,n=e.count;t<n;t++)s.fromBufferAttribute(e,t),j.toWorkingColorSpace(s,P),e.setXYZ(t,s.r,s.g,s.b)}_loadLibrary(e,r){const s=new M(this.manager);return s.setPath(this.decoderPath),s.setResponseType(r),s.setWithCredentials(this.withCredentials),new Promise((t,n)=>{s.load(e,t,void 0,n)})}preload(){return this._initDecoder(),this}_initDecoder(){if(this.decoderPending)return this.decoderPending;const e=typeof WebAssembly!="object"||this.decoderConfig.type==="js",r=[];return e?r.push(this._loadLibrary("draco_decoder.js","text")):(r.push(this._loadLibrary("draco_wasm_wrapper.js","text")),r.push(this._loadLibrary("draco_decoder.wasm","arraybuffer"))),this.decoderPending=Promise.all(r).then(s=>{const t=s[0];e||(this.decoderConfig.wasmBinary=s[1]);const n=he.toString(),o=["/* draco decoder */",t,"","/* worker */",n.substring(n.indexOf("{")+1,n.lastIndexOf("}"))].join(`
`);this.workerSourceURL=URL.createObjectURL(new Blob([o]))}),this.decoderPending}_getWorker(e,r){return this._initDecoder().then(()=>{if(this.workerPool.length<this.workerLimit){const t=new Worker(this.workerSourceURL);t._callbacks={},t._taskCosts={},t._taskLoad=0,t.postMessage({type:"init",decoderConfig:this.decoderConfig}),t.onmessage=function(n){const o=n.data;switch(o.type){case"decode":t._callbacks[o.id].resolve(o);break;case"error":t._callbacks[o.id].reject(o);break;default:console.error('THREE.DRACOLoader: Unexpected message, "'+o.type+'"')}},this.workerPool.push(t)}else this.workerPool.sort(function(t,n){return t._taskLoad>n._taskLoad?-1:1});const s=this.workerPool[this.workerPool.length-1];return s._taskCosts[e]=r,s._taskLoad+=r,s})}_releaseTask(e,r){e._taskLoad-=e._taskCosts[r],delete e._callbacks[r],delete e._taskCosts[r]}debug(){console.log("Task load: ",this.workerPool.map(e=>e._taskLoad))}dispose(){for(let e=0;e<this.workerPool.length;++e)this.workerPool[e].terminate();return this.workerPool.length=0,this.workerSourceURL!==""&&URL.revokeObjectURL(this.workerSourceURL),this}}function he(){let l,e;onmessage=function(o){const a=o.data;switch(a.type){case"init":l=a.decoderConfig,e=new Promise(function(u){l.onModuleLoaded=function(h){u({draco:h})},DracoDecoderModule(l)});break;case"decode":const i=a.buffer,f=a.taskConfig;e.then(u=>{const h=u.draco,d=new h.Decoder;try{const c=r(h,d,new Int8Array(i),f),p=c.attributes.map(m=>m.array.buffer);c.index&&p.push(c.index.array.buffer),self.postMessage({type:"decode",id:a.id,geometry:c},p)}catch(c){console.error(c),self.postMessage({type:"error",id:a.id,error:c.message})}finally{h.destroy(d)}});break}};function r(o,a,i,f){const u=f.attributeIDs,h=f.attributeTypes;let d,c;const p=a.GetEncodedGeometryType(i);if(p===o.TRIANGULAR_MESH)d=new o.Mesh,c=a.DecodeArrayToMesh(i,i.byteLength,d);else if(p===o.POINT_CLOUD)d=new o.PointCloud,c=a.DecodeArrayToPointCloud(i,i.byteLength,d);else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");if(!c.ok()||d.ptr===0)throw new Error("THREE.DRACOLoader: Decoding failed: "+c.error_msg());const m={index:null,attributes:[]};for(const k in u){const g=self[h[k]];let b,_;if(f.useUniqueIDs)_=u[k],b=a.GetAttributeByUniqueId(d,_);else{if(_=a.GetAttributeId(d,o[u[k]]),_===-1)continue;b=a.GetAttribute(d,_)}const A=t(o,a,d,k,g,b);k==="color"&&(A.vertexColorSpace=f.vertexColorSpace),m.attributes.push(A)}return p===o.TRIANGULAR_MESH&&(m.index=s(o,a,d)),o.destroy(d),m}function s(o,a,i){const u=i.num_faces()*3,h=u*4,d=o._malloc(h);a.GetTrianglesUInt32Array(i,h,d);const c=new Uint32Array(o.HEAPF32.buffer,d,u).slice();return o._free(d),{array:c,itemSize:1}}function t(o,a,i,f,u,h){const d=h.num_components(),p=i.num_points()*d,m=p*u.BYTES_PER_ELEMENT,k=n(o,u),g=o._malloc(m);a.GetAttributeDataArrayForAllPoints(i,h,k,m,g);const b=new u(o.HEAPF32.buffer,g,p).slice();return o._free(g),{name:f,array:b,itemSize:d}}function n(o,a){switch(a){case Float32Array:return o.DT_FLOAT32;case Int8Array:return o.DT_INT8;case Int16Array:return o.DT_INT16;case Int32Array:return o.DT_INT32;case Uint8Array:return o.DT_UINT8;case Uint16Array:return o.DT_UINT16;case Uint32Array:return o.DT_UINT32}}}const y={key:[0,0],ease:new T,position:new T,up:new T(0,1,0),rotate:new q,current:"Run",fadeDuration:.5,runVelocity:400,walkVelocity:80};function fe(l){const e=y.key;switch(l.code){case"ArrowUp":case"KeyW":case"KeyZ":e[0]=-1;break;case"ArrowDown":case"KeyS":e[0]=1;break;case"ArrowLeft":case"KeyA":case"KeyQ":e[1]=-1;break;case"ArrowRight":case"KeyD":e[1]=1;break;case"ShiftLeft":case"ShiftRight":e[2]=1;break}}function pe(l){const e=y.key;switch(l.code){case"ArrowUp":case"KeyW":case"KeyZ":e[0]=e[0]<0?0:e[0];break;case"ArrowDown":case"KeyS":e[0]=e[0]>0?0:e[0];break;case"ArrowLeft":case"KeyA":case"KeyQ":e[1]=e[1]<0?0:e[1];break;case"ArrowRight":case"KeyD":e[1]=e[1]>0?0:e[1];break;case"ShiftLeft":case"ShiftRight":e[2]=0;break}}const ye=async(l,e,r)=>{const s=await me(l),t=s.scene,n=s.animations,o=new z(t),a=new H(16777215,2);a.castShadow=!0,a.target=t,a.position.set(0,5,-2);const i=a.shadow.camera;i.far=300,i.near=100,i.left=-100,i.right=100,i.top=100,i.bottom=-200,t.add(a),y.position.copy(e.controls.target);const f={Idle:o.clipAction(n[0]),Walk:o.clipAction(n[3]),Run:o.clipAction(n[1])};for(const c in f){const p=f[c];p.enabled=!0,p.setEffectiveTimeScale(1),c!=="Idle"&&p.setEffectiveWeight(0)}f.Idle.play();function u(c){const p=y.fadeDuration,m=y.key,k=y.up,g=y.ease,b=y.rotate,_=y.position,A=e.controls.getAzimuthalAngle(),R=!(m[0]===0&&m[1]===0)?m[2]?"Run":"Walk":"Idle";if(y.current!=R){const L=f[R],C=f[y.current];y.current=R,d(L,1),C.fadeOut(p),L.reset().fadeIn(p).play()}if(y.current!=="Idle"){const L=e.controls.target.clone(),C=y.current=="Run"?y.runVelocity:y.walkVelocity;g.set(m[1],0,m[0]).multiplyScalar(C*c);const G=h(Math.atan2(g.x,g.z)+A);b.setFromAxisAngle(k,G),y.ease.applyAxisAngle(k,A),_.add(g),t.quaternion.rotateTowards(b,-.05),e.controls.target.add(g);const U=r.getLocalInfoFromWorld(e.controls.target);U&&e.controls.target.setY(U.point.y),L.sub(e.controls.target),e.camera.position.sub(L),t.position.copy(e.controls.target)}o.update(c)}function h(c){return Math.atan2(Math.sin(c),Math.cos(c))}function d(c,p){c.enabled=!0,c.setEffectiveTimeScale(1),c.setEffectiveWeight(p)}return e.renderer.domElement.addEventListener("keydown",fe),e.renderer.domElement.addEventListener("keyup",pe),e.addEventListener("update",c=>{u(c.delta)}),t.scale.setScalar(50),e.scene.add(t),t};async function me(l){const e=new ue;e.setDecoderPath("../lib/draco/gltf/");const r=new ne;r.setDRACOLoader(e);const s=await r.loadAsync(l),t=s.scene;return t.traverse(n=>{n.castShadow=!0,n.receiveShadow=!0}),t.castShadow=!0,t.receiveShadow=!0,s}const ge=()=>{const l=Q.create({imgSource:new Z,demSource:new Y,lon0:90,minLevel:10,bounds:[90,30,100,40]});l.rotateX(-Math.PI/2),l.receiveShadow=!0;const e=new X;e.controls.enableDamping=!1,e.controls.controlsMode="ORBIT",e.controls.enablePan=!1,e.controls.stopListenToKeyEvents(),e.controls.maxDistance=2e3,e.renderer.shadowMap.enabled=!0,e.dirLight.intensity=.5,e.ambLight.intensity=.5;const r=new T(94.39977,36.0022,4085.5),s=new T(94.4003,35.9989,4185);return e.controls.target.copy(l.geo2world(r)),e.camera.position.copy(l.geo2world(s)),e.fogFactor=.3,setTimeout(()=>{e.addEventListener("update",()=>{J(l,e.camera)})},5e3),{viewer:e,map:l}},{viewer:v,map:E}=ge(),we=l=>(F(()=>{l&&l.value&&(v.addTo(l.value),v.scene.add(E))}),W(()=>{E.dispose()}),{viewer:v,map:E}),ke={class:"demo-container"},be={class:"state"},_e={class:"location"},Ae={class:"loading"},Le=ae({__name:"Walk",setup(l){const e=x(void 0),{viewer:r,map:s}=we(e),t=ee(s,r),n=te(s),o=x();oe(r.controls,o);const a=x(),i=re(a),f=()=>{i.update()};se(r.scene);let u;return F(async()=>{r.addEventListener("update",f),u=await ye("../../model/Soldier.glb",r,s),u.position.copy(r.controls.target)}),W(()=>{u.traverse(h=>{h instanceof $&&(h.geometry.dispose(),h.material.dispose())}),r.scene.remove(u)}),(h,d)=>(ce(),ie("div",ke,[w("div",{ref_key:"viewerRef",ref:e,class:"viewer"},null,512),d[0]||(d[0]=w("div",{id:"help"},[w("b",null,"光标键 | WASD"),de(" 移动，按下shift快速移动")],-1)),w("div",{class:"compass",ref_key:"compassRef",ref:o},null,512),w("div",be,[w("div",_e,[w("span",null,"经度："+S(D(t).x.toFixed(6))+"° ",1),w("span",null,"纬度："+S(D(t).y.toFixed(6))+"° ",1),w("span",null,"海拔："+S(D(t).z.toFixed(1))+"m ",1)]),w("div",Ae,S(D(n)),1)]),w("div",{class:"stats",ref_key:"statsRef",ref:a},null,512)]))}}),Ie=le(Le,[["__scopeId","data-v-e3b21081"]]);export{Ie as default};
